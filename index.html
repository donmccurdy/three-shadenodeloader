<!DOCTYPE html>
<meta charset="utf-8">
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
</style>
<script src="./node_modules/dat.gui/build/dat.gui.js"></script>
<script src="./node_modules/three/build/three.js"></script>
<script src="./node_modules/three/examples/js/controls/OrbitControls.js"></script>
<script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
<script type="module">
  import { ShadeLoader } from './ShadeLoader.js';
  import { TimerNode, FloatNode, Vector3Node } from './node_modules/three/examples/js/nodes/Nodes.js';

  const renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.setClearColor( 0x202020 );
  renderer.physicallyCorrectLights = true;
  renderer.gammaOutput = true;
  renderer.gammaFactor = 2.2;
  document.body.appendChild( renderer.domElement );

  const timerNode = new TimerNode( 1.0 );
  const micNode = new FloatNode( 0.01 );

  let mesh, geometry, material;

  const props = {
    suzanne: null,
    grass: null,
    roundedCube: null,
    cube: new THREE.BoxBufferGeometry(1.8, 1.8, 1.8),
    sphere: new THREE.SphereBufferGeometry( 1.8, 32, 32 ),
    plane: new THREE.PlaneBufferGeometry( 5, 5, 64, 64 ).rotateX( - 1 * Math.PI / 2 )
  };

  const examples = [

    {name: 'Checkers', shader: 'assets/shaders/Checkers/Graph.json', prop: 'cube'},
    {name: 'Dissolve', shader: 'assets/shaders/Dissolve/Graph.json', prop: 'suzanne'},
    {name: 'Fake Volume', shader: 'assets/shaders/FakeVolume/Graph.json', prop: 'sphere'},
    {name: 'Grass', shader: 'assets/shaders/Grass/Graph.json', prop: 'grass'},
    {name: 'Hologram', shader: 'assets/shaders/Hologram/Graph.json', prop: 'suzanne'},
    {name: 'Instancing Grid', shader: 'assets/shaders/InstancingGrid/Graph.json', prop: 'roundedCube'},
    {name: 'Wire Ripple', shader: 'assets/shaders/WireRipple/Graph.json', prop: 'plane'},
    {name: 'Wireframe', shader: 'assets/shaders/Wireframe/Graph.json', prop: 'sphere'},
    {name: '[broken] Clouds', shader: 'assets/shaders/Clouds/Graph.json', prop: 'cube'},
    {name: '[broken] Explosion', shader: 'assets/shaders/Explosion/Graph.json', prop: 'sphere'},
    {name: '[broken] Mask Blend', shader: 'assets/shaders/MaskBlend/Graph.json', prop: 'cube'},
    {name: '[broken] Ripple', shader: 'assets/shaders/Ripple/Graph.json', prop: 'plane'},

  ];
  let selectedExample = examples[ 0 ];
  const api = { model: selectedExample.name };
  const gui = new dat.GUI();
  gui.add( api, 'model', examples.map( ( d ) => d.name ) ).onChange( () => {
    selectedExample = examples.find( ( d ) => api.model === d.name );
    mesh.parent.remove( mesh );
    mesh.geometry.dispose();
    mesh.material.dispose();
    initShader();
  } );

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 100 );
  camera.position.set( 5, 3, 4 );
  scene.add( camera );

  const controls = new THREE.OrbitControls( camera, renderer.domElement );

  const hemiLight = new THREE.HemisphereLight( 0xDDBBBB, 0xBBBBDD, 1.0 );
  scene.add( hemiLight );

  const directLight = new THREE.PointLight( 0x888888, 1.0 );
  directLight.position.set( 3, 5, 3 );
  scene.add( directLight );

  scene.add( new THREE.GridHelper() );

  const clock = new THREE.Clock();

  const modelLoader = new THREE.GLTFLoader();

  modelLoader.load( 'assets/Suzanne.glb', ( { scene } ) => {

    props.suzanne = scene.children[ 0 ].geometry;

    animate();

  } );

  modelLoader.load( 'assets/GrassBlade.glb', ( { scene } ) => {

    props.grass = scene.children[ 0 ].geometry;

    animate();

  } );

  modelLoader.load( 'assets/RoundedCube.glb', ( { scene } ) => {

    props.roundedCube = scene.children[ 0 ].geometry;

    animate();

  } );

  const loader = new ShadeLoader();

  loader.setFactory( ( nodeDef ) => {

    switch ( nodeDef.class ) {

      case 'TimeNode':
        return timerNode;

      case 'MicNode':
        // TODO(donmccurdy): Add some audio.
        return micNode;

      case 'PropNode':
        // TODO(donmccurdy): Include visible properties.
        return new Vector3Node(
          nodeDef.options.position[ 0 ],
          nodeDef.options.position[ 1 ],
          nodeDef.options.position[ 2 ]
        );

    }

    throw new Error( `Unprovided node type: ${nodeDef.class}.` );


  } );

  const initShader = () => {

    loader.load(

      selectedExample.shader,

      ( _material ) => {

        material = _material;

        animate();

      },

      () => console.info( '[THREE.ShadeLoader] Progress.' ),

      ( e ) => console.error( e )

    );

  };

  initShader();

  function animate () {

    if ( ! props.suzanne || ! props.grass || ! props.roundedCube || ! material ) return;

    geometry = props[selectedExample.prop];

    populateInstances();

    // FWidthNode
    if ( material.userData.needsDerivatives ) {

      const onBeforeCompile = material.onBeforeCompile;

      material.onBeforeCompile = function () {

        onBeforeCompile.apply(this, arguments);

        material.extensions.derivatives = true;

      };

    }

    if ( material.userData.needsBarycentric ) {

      geometry = window.geometry = geometry.toNonIndexed();

      const vertexCount = geometry.attributes.position.count;
      const barycentric = new THREE.BufferAttribute( new Uint16Array( vertexCount * 3 ), 3 );

      for ( let i = 0; i < geometry.attributes.position.count; i += 3 ) {

        barycentric.setXYZ( i, 1, 0, 0 );
        barycentric.setXYZ( i + 1, 0, 1, 0 );
        barycentric.setXYZ( i + 2, 0, 0, 1 );

      }

      geometry.addAttribute( 'barycentric', barycentric );

    }

    mesh = new THREE.Mesh( geometry, material );
    mesh.position.y = 1;

    scene.add( mesh );

    camera.lookAt( mesh.position );

    renderer.render( scene, camera );

    renderer.setAnimationLoop( (  ) => {

      timerNode.updateFrame( { delta: clock.getDelta(), time: clock.getElapsedTime() } );

      renderer.render( scene, camera );

    } );

    // debug
    Object.assign( window, { camera, scene, renderer, material, mesh } );

  }

  function populateInstances () {

    const instanceCount = material.userData.instanceCount;

    if ( instanceCount <= 1 ) return;

    const instanceID = new THREE.InstancedBufferAttribute(
      new Float32Array( new Array( instanceCount ).fill( 0 ).map( ( _, index ) => index ) ),
      1
    );

    geometry = new THREE.InstancedBufferGeometry().copy( geometry );
    geometry.addAttribute( 'instanceID', instanceID );
    geometry.maxInstancedCount = instanceCount;

  }
</script>
