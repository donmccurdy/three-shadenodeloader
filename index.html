<!DOCTYPE html>
<meta charset="utf-8">
<title>three.js • examples • shade node loader</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
</style>
<script src="./node_modules/dat.gui/build/dat.gui.js"></script>
<script src="./node_modules/three/build/three.js"></script>
<script src="./node_modules/three/examples/js/controls/OrbitControls.js"></script>
<script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
<script type="module">
  import { ShadeNodeLoader } from './ShadeNodeLoader.js';
  import { TimerNode, FloatNode, Vector3Node } from './node_modules/three/examples/js/nodes/Nodes.js';

  const renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.setClearColor( 0x202020 );
  renderer.physicallyCorrectLights = true;
  renderer.gammaOutput = true;
  renderer.gammaFactor = 2.2;
  document.body.appendChild( renderer.domElement );

  const timerNode = new TimerNode( 1.0 );
  const micNode = new FloatNode( 0.01 );

  const otherProps = [];

  let mesh, geometry, material;

  //

  const props = {
    suzanne: null,
    grass: null,
    roundedCube: null,
    cube: new THREE.BoxBufferGeometry(1.8, 1.8, 1.8),
    sphere: new THREE.SphereBufferGeometry( 1.8, 32, 32 ),
    plane: new THREE.PlaneBufferGeometry( 5, 5, 64, 64 ).rotateX( - 1 * Math.PI / 2 )
  };

  const examples = [

    {name: 'Checkers', shader: 'assets/shaders/Checkers/Graph.json', prop: 'cube'},
    {name: 'Dissolve', shader: 'assets/shaders/Dissolve/Graph.json', prop: 'suzanne'},
    {name: 'Fake Volume', shader: 'assets/shaders/FakeVolume/Graph.json', prop: 'sphere'},
    {name: 'Grass', shader: 'assets/shaders/Grass/Graph.json', prop: 'grass'},
    {name: 'Hologram', shader: 'assets/shaders/Hologram/Graph.json', prop: 'suzanne'},
    {name: 'Instancing Grid', shader: 'assets/shaders/InstancingGrid/Graph.json', prop: 'roundedCube'},
    {name: 'Wire Ripple', shader: 'assets/shaders/WireRipple/Graph.json', prop: 'plane'},
    {name: 'Wireframe', shader: 'assets/shaders/Wireframe/Graph.json', prop: 'sphere'},
    {name: '[broken] Clouds', shader: 'assets/shaders/Clouds/Graph.json', prop: 'cube'},
    {name: '[broken] Explosion', shader: 'assets/shaders/Explosion/Graph.json', prop: 'sphere'},
    {name: '[broken] Mask Blend', shader: 'assets/shaders/MaskBlend/Graph.json', prop: 'cube'},
    {name: '[broken] Ripple', shader: 'assets/shaders/Ripple/Graph.json', prop: 'plane'},

  ];
  let selectedExample = examples[ 0 ];
  const api = { model: selectedExample.name };
  const gui = new dat.GUI();
  gui.add( api, 'model', examples.map( ( d ) => d.name ) ).onChange( () => {
    selectedExample = examples.find( ( d ) => api.model === d.name );
    mesh.parent.remove( mesh );
    mesh.geometry.dispose();
    mesh.material.dispose();
    otherProps.forEach( ( o ) => o.parent.remove( o ) );
    otherProps.length = 0;

    loadShader( selectedExample.shader ).then( ( _material ) => {

      material = _material;
      animate();

    } );

  } );

  //

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 100 );
  camera.position.set( 5, 3, 4 );
  scene.add( camera );

  const controls = new THREE.OrbitControls( camera, renderer.domElement );

  const hemiLight = new THREE.HemisphereLight( 0xDDBBBB, 0xBBBBDD, 1.0 );
  scene.add( hemiLight );

  const directLight = new THREE.PointLight( 0x888888, 1.0 );
  directLight.position.set( 3, 5, 3 );
  scene.add( directLight );

  scene.add( new THREE.GridHelper() );

  const clock = new THREE.Clock();

  //

  const modelLoader = new THREE.GLTFLoader();

  const loadGeometry = ( url ) => new Promise( ( resolve, reject ) => {

    modelLoader.load( url, ( { scene } ) => resolve( scene.children[ 0 ].geometry ), undefined, reject );

  } );

  //

  const loader = new ShadeNodeLoader();

  const customNodeFactory = ( nodeDef ) => {

    switch ( nodeDef.class ) {

      case 'TimeNode':
        return timerNode;

      case 'MicNode':
        // TODO(donmccurdy): Add some audio.
        return micNode;

      case 'PropNode':
        const prop = new THREE.Mesh(
          new THREE.SphereBufferGeometry( 1, 32, 32 ),
          new THREE.MeshStandardMaterial( { color: 0x858585, roughness: 1, metalness: 0 } )
        );
        prop.name = nodeDef.options.userLabel || '';
        prop.position.fromArray( nodeDef.options.position );
        prop.scale.fromArray( nodeDef.options.scale );
        scene.add( prop );
        otherProps.push( prop );
        return new Vector3Node(
          prop.position.x,
          prop.position.y,
          prop.position.z
        );

    }

    throw new Error( `Unprovided node type: ${nodeDef.class}.` );

  };

  loader.setFactory( customNodeFactory );

  const loadShader = ( url ) => new Promise( ( resolve, reject ) => {

    loader.load( url, resolve, undefined, reject );

  } );

  //

  Promise.all([
    loadShader( selectedExample.shader ),
    loadGeometry( 'assets/Suzanne.glb' ),
    loadGeometry( 'assets/GrassBlade.glb' ),
    loadGeometry( 'assets/RoundedCube.glb' ),
  ])
    .then( ( [ _material, suzanne, grass, roundedCube ] ) => {

      material = _material;

      props.suzanne = suzanne;
      props.grass = grass;
      props.roundedCube = roundedCube;

      animate();

    } )
    .catch( ( e ) => {

      console.error( e );

    } );

  //

  function animate () {

    geometry = props[selectedExample.prop];

    // Instancing
    if ( material.userData.instanceCount > 1 ) geometry = makeInstances( geometry, material );

    // FWidthNode
    if ( material.userData.needsDerivatives ) material = makeDerivatives( material );

    // BarymetricNode
    if ( material.userData.needsBarycentric ) geometry = makeBarymetric( geometry );

    mesh = new THREE.Mesh( geometry, material );
    mesh.position.y = 1;

    scene.add( mesh );

    camera.lookAt( mesh.position );

    renderer.render( scene, camera );

    renderer.setAnimationLoop( (  ) => {

      timerNode.updateFrame( { delta: clock.getDelta(), time: clock.getElapsedTime() } );

      renderer.render( scene, camera );

    } );

    // debug
    Object.assign( window, { camera, scene, renderer, material, mesh } );

  }

  function makeDerivatives ( material ) {

    const onBeforeCompile = material.onBeforeCompile;

    material.onBeforeCompile = function () {

      onBeforeCompile.apply(this, arguments);

      material.extensions.derivatives = true;

    };

    return material;

  }

  function makeBarymetric ( geometry ) {

    geometry = geometry.toNonIndexed();

    const vertexCount = geometry.attributes.position.count;
    const barycentric = new THREE.BufferAttribute( new Uint16Array( vertexCount * 3 ), 3 );

    for ( let i = 0; i < geometry.attributes.position.count; i += 3 ) {

      barycentric.setXYZ( i, 1, 0, 0 );
      barycentric.setXYZ( i + 1, 0, 1, 0 );
      barycentric.setXYZ( i + 2, 0, 0, 1 );

    }

    geometry.addAttribute( 'barycentric', barycentric );

    return geometry;

  }

  function makeInstances ( geometry, material ) {

    const instanceCount = material.userData.instanceCount;

    const instanceID = new THREE.InstancedBufferAttribute(
      new Float32Array( new Array( instanceCount ).fill( 0 ).map( ( _, index ) => index ) ),
      1
    );

    geometry = new THREE.InstancedBufferGeometry().copy( geometry );
    geometry.addAttribute( 'instanceID', instanceID );
    geometry.maxInstancedCount = instanceCount;

    return geometry;

  }

  function createEnvironment () {

  }
</script>
