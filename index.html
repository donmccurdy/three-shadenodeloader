<!DOCTYPE html>
<meta charset="utf-8">
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
</style>
<script src="./node_modules/three/build/three.js"></script>
<script src="./node_modules/three/examples/js/controls/OrbitControls.js"></script>
<script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
<script type="module">
  import { ShadeLoader } from './ShadeLoader.js';

  const renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.setClearColor( 0x202020 );
  renderer.physicallyCorrectLights = true;
  renderer.gammaOutput = true;
  renderer.gammaFactor = 2.2;
  document.body.appendChild( renderer.domElement );

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 100 );
  camera.position.set( 5, 3, 4 );
  scene.add( camera );

  const controls = new THREE.OrbitControls( camera );

  const hemiLight = new THREE.HemisphereLight( 0x4488AA, 0x22DD77, 1.0 );
  scene.add( hemiLight );

  const directLight = new THREE.PointLight( 0x888888, 1.0 );
  directLight.position.set( 3, 5, 3 );
  scene.add( directLight );

  scene.add( new THREE.GridHelper() );

  const clock = new THREE.Clock();

  let mesh, geometry, material;

  geometry = new THREE.BoxBufferGeometry(1.8, 1.8, 1.8);

  // const modelLoader = new THREE.GLTFLoader();

  // modelLoader.load( 'assets/Suzanne.glb', ( { scene } ) => {

  //   geometry = scene.children[ 0 ].geometry;

  //   animate();

  // } );

  const loader = new ShadeLoader();

  loader.load(

    'assets/InstancingGrid/Graph.json',

    ( _material ) => {

      material = _material;

      animate();

    },

    () => console.info( '[THREE.ShadeLoader] Progress.' ),

    ( e ) => console.error( e )

  );

  function animate () {

    if ( ! geometry || ! material ) return;

    populateInstances();

    const mesh = new THREE.Mesh( geometry, material );
    mesh.position.y = 1;

    scene.add( mesh );

    camera.lookAt( mesh.position );

    renderer.render( scene, camera );

    renderer.setAnimationLoop( (  ) => {

      const delta = clock.getDelta();
      material.userData.timerNodes.forEach( ( node ) => {

        node.updateFrame( { delta, time: clock.getElapsedTime() } );

      } );

      renderer.render( scene, camera );

    } );

    // debug
    Object.assign( window, { camera, scene, renderer, material, mesh } );

  }

  function populateInstances () {

    const instanceCount = material.userData.instanceCount;

    if ( instanceCount <= 1 ) return;

    const instanceID = new THREE.InstancedBufferAttribute(
      new Float32Array( new Array( instanceCount ).fill( 0 ).map( ( _, index ) => index ) ),
      1
    );

    geometry = new THREE.InstancedBufferGeometry().copy( geometry );
    geometry.addAttribute( 'instanceID', instanceID );
    geometry.maxInstancedCount = instanceCount;

  }
</script>
